#!/bin/sh
# WARNING: This file was auto-generated. Do not edit!

QMAILDIR=/usr/local/qmail
UIDQ="1004"
UIDR="1005"
UIDS="1006"
GIDQ="1000"
SPLIT=23

showHelp() {
  echo "Usage: qmail-fixq [option [-m]"
  echo
  echo -e "  -c\tcheck structure of the queue for issues (default)"
  echo -e "  -f\tfix issues of the queue"
  echo -e "  -h\tShow this help"
#  echo -e "  -m\tincludes check of messages (this could take a long time)"  # useless in practice, messages
                                                                               # will be fixed always
  echo
  exit 0
}
fixqueue() {
  echo -n "Fixing queue ..."
  T=$QMAILDIR/queue     # just to shortening next commands (T: tmp)
  mkdir -p $T/bounce $T/lock $T/pid
  i=0
  #until [ $i -eq `head -1 conf-split` ]
  until [ $i -eq "$SPLIT" ]
  do
    # Create splitted queue subdirectories
    mkdir -p $T/info/$i $T/intd/$i $T/local/$i $T/mess/$i $T/remote/$i $T/todo/$i
    i=$(($i+1))
  done
  # set all:
  chown -R $UIDQ:$GIDQ  $QMAILDIR/queue
  chmod -R 0750         $QMAILDIR/queue
  # set new: bounce, info, local, remote
  chown -R $UIDS:$GIDQ  $T/bounce $T/info $T/local $T/remote
  chmod -R 0700         $T/info $T/intd $T/local $T/pid $T/remote
  # upgrade/qmail-fixq: set correct mode of files (messages)
  find $QMAILDIR/queue/ -type f -exec chmod 644 {} + -exec chown $UIDQ:0 {} +
  
  # special files in 'lock'
  dd if=/dev/zero of=$QMAILDIR/queue/lock/tcpto bs=2048 count=1 2>/dev/null
  chown $UIDR:$GIDQ  $QMAILDIR/queue/lock/tcpto
  chmod 0644         $QMAILDIR/queue/lock/tcpto
  
  touch $QMAILDIR/queue/lock/sendmutex
  chown $UIDS:$GIDQ  $QMAILDIR/queue/lock/sendmutex
  chmod 0600         $QMAILDIR/queue/lock/sendmutex
  
  mkfifo             $QMAILDIR/queue/lock/trigger 2>/dev/null
  chown $UIDS:$GIDQ  $QMAILDIR/queue/lock/trigger
  chmod 0622         $QMAILDIR/queue/lock/trigger
  echo "done!"
}
chkqueue() {
  echo "Checking queue for issues ..."
  SPLITMESS=`find $QMAILDIR/queue/mess/*   -type d -print | wc -l`
  SPLITINFO=`find $QMAILDIR/queue/info/*   -type d -print | wc -l`
  SPLITINTD=`find $QMAILDIR/queue/intd/*   -type d -print | wc -l`
  SPLITLOCL=`find $QMAILDIR/queue/local/*  -type d -print | wc -l`
  SPLITREMT=`find $QMAILDIR/queue/remote/* -type d -print | wc -l`
  SPLITTODO=`find $QMAILDIR/queue/todo/*   -type d -print | wc -l`
  if [ "$SPLIT" -ne "$SPLITMESS" ]; then SPLITERR=1 ; fi
  if [ "$SPLIT" -ne "$SPLITINFO" ]; then SPLITERR=1 ; fi
  if [ "$SPLIT" -ne "$SPLITINTD" ]; then SPLITERR=1 ; fi
  if [ "$SPLIT" -ne "$SPLITLOCL" ]; then SPLITERR=1 ; fi
  if [ "$SPLIT" -ne "$SPLITREMT" ]; then SPLITERR=1 ; fi
  if [ "$SPLIT" -ne "$SPLITTODO" ]; then SPLITERR=1 ; fi

  if [ "$SPLITERR" ] ; then
      echo "invalid queue split" ; ERR=1
   else
      echo "splitting ok!"
  fi
  # check the directory structure
  # group have to be \'qmail\' always (recursive)
  GRPNAME=`getent group $GIDQ | awk -F: '{print $1}'`
  find $QMAILDIR/queue/* -type d -print | xargs ls -ld | awk '{print $4}' | grep -v $GRPNAME >/dev/null
  if [ $? -eq 0 ] ; then GRPERR=1 ; fi

  # check for uid qmailq/qmails on splitted directories
  USRNAME=`id -un $UIDQ`
  for f in intd mess todo local remote info
  do
    if [ "$f" = "local" ] ; then USRNAME=`id -un $UIDS` ; fi

#echo $f
    ls -ld $QMAILDIR/queue/$f | awk '{print $3}' | grep -v $USRNAME >/dev/null
    if [ $? -eq 0 ] ; then USRERR=1 ; fi
#find $QMAILDIR/queue/$f/*
    find $QMAILDIR/queue/$f/* | xargs ls -ld | awk '{print $3}' | grep -v $USRNAME >/dev/null
    if [ $? -eq 0 ] ; then USRERR=1 ; fi
  done
  # check pid, bounce
  ls -ld $QMAILDIR/queue/bounce | awk '{print $3}' | grep -v $USRNAME >/dev/null
    if [ $? -eq 0 ] ; then USRERR=1 ; fi
  USRNAME=`id -un $UIDQ`   # until now USRNAME was 'qmails'
  ls -ld $QMAILDIR/queue/pid    | awk '{print $3}' | grep -v $USRNAME >/dev/null
    if [ $? -eq 0 ] ; then USRERR=1 ; fi

  # special: lock
#echo U: $USRNAME
  ls -ld $QMAILDIR/queue/lock   | awk '{print $3}' | grep -v $USRNAME >/dev/null
  if [ $? -eq 0 ] ; then USRERR=1 ; fi
  USRNAME=`id -un $UIDS`   # ... back to USRNAME was 'qmails'
  ls -l $QMAILDIR/queue/lock/trigger   | awk '{print $3}' | grep -v $USRNAME >/dev/null
  if [ $? -eq 0 ] ; then USRERR=1 ; fi
#echo U: $USRNAME
  ls -l $QMAILDIR/queue/lock/sendmutex | awk '{print $3}' | grep -v $USRNAME >/dev/null
  if [ $? -eq 0 ] ; then USRERR=1 ; fi

  USRNAME=`id -un $UIDR`   # ... and now we need USRNAME 'qmailr'
#echo U: $USRNAME
  ls -l $QMAILDIR/queue/lock/tcpto | awk '{print $3}' | grep -v $USRNAME >/dev/null
  if [ $? -eq 0 ] ; then USRERR=1 ; fi

  if [ "$USRERR" ] || [ "$GRPERR" ] ; then
     echo "invalid owner(s) or group!"
   else
     echo "user/group ok!"
  fi

  # check permissions w/ and w/o subdirectories
  stat -c %a `ls -d $QMAILDIR/queue/mess`     | grep -v 750 >/dev/null
  if [ $? -eq 0 ] ; then PRMERR=1 ; fi
  stat -c %a `ls -d $QMAILDIR/queue/mess/*`   | grep -v 750 >/dev/null
  if [ $? -eq 0 ] ; then PRMERR=1 ; fi
  stat -c %a `ls -d $QMAILDIR/queue/todo`     | grep -v 750 >/dev/null
  if [ $? -eq 0 ] ; then PRMERR=1 ; fi
  stat -c %a `ls -d $QMAILDIR/queue/todo/*`   | grep -v 750 >/dev/null
  if [ $? -eq 0 ] ; then PRMERR=1 ; fi
  stat -c %a `ls -d $QMAILDIR/queue/info`     | grep -v 700 >/dev/null
  if [ $? -eq 0 ] ; then PRMERR=1 ; fi
  stat -c %a `ls -d $QMAILDIR/queue/info/*`   | grep -v 700 >/dev/null
  if [ $? -eq 0 ] ; then PRMERR=1 ; fi
  stat -c %a `ls -d $QMAILDIR/queue/intd`     | grep -v 700 >/dev/null
  if [ $? -eq 0 ] ; then PRMERR=1 ; fi
  stat -c %a `ls -d $QMAILDIR/queue/intd/*`   | grep -v 700 >/dev/null
  if [ $? -eq 0 ] ; then PRMERR=1 ; fi
  stat -c %a `ls -d $QMAILDIR/queue/local`    | grep -v 700 >/dev/null
  if [ $? -eq 0 ] ; then PRMERR=1 ; fi
  stat -c %a `ls -d $QMAILDIR/queue/local/*`  | grep -v 700 >/dev/null
  if [ $? -eq 0 ] ; then PRMERR=1 ; fi
  stat -c %a `ls -d $QMAILDIR/queue/remote`   | grep -v 700 >/dev/null
  if [ $? -eq 0 ] ; then PRMERR=1 ; fi
  stat -c %a `ls -d $QMAILDIR/queue/remote/*` | grep -v 700 >/dev/null
  if [ $? -eq 0 ] ; then PRMERR=1 ; fi

  if [ "$PRMERR" ] ; then
     echo "invalid permissions(s)!"
   else
     echo "permissions ok!"
  fi

#  echo
}

if [ ! "$1" ] ; then chkqueue ; exit 0 ; fi
while getopts :hcf o; do
    case "${o}" in
        h) showHelp;;
        f) fixqueue;;
        c) chkqueue;;
        m) FIXMSG="Y" ; fixqueue;;
        *) echo Invalid option! ; showHelp;;
    esac
done ; shift 0

exit 0
